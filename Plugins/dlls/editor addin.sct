<scriptlet>
<implements type="Automation" id="dispatcher">
  <property name="PluginEvent">
    <get/>
  </property>
  <property name="PluginDescription">
    <get/>
  </property>
  <property name="PluginExtendedProperties">
    <get/>
  </property>
  <property name="PluginFileFilters">
    <get/>
  </property>
  <property name="PluginArguments">
    <get/>
    <put/>
  </property>
  <property name="PluginVariables">
    <get/>
    <put/>
  </property>
  <method name="PluginOnEvent"/>
  <method name="ExecFilterCommand"/>
  <method name="MakeUpper"/>
  <method name="MakeLower"/>
  <method name="RemoveDuplicates"/>
  <method name="CountDuplicates"/>
  <method name="SortAscending"/>
  <method name="SortDescending"/>
  <method name="ReverseColumns"/>
  <method name="ReverseLines"/>
  <method name="SelectColumns"/>
  <method name="SelectLines"/>
  <method name="Replace" internalName="ReplaceText"/>
  <method name="Tokenize"/>
  <method name="Trim"/>
  <method name="AIConvertText"/>
  <method name="ShowSettingsDialog"/>
</implements>

<script language="JScript">

var REGKEY_PATH = "Plugins\\editor addin.sct/";

var wsh = new ActiveXObject("WScript.Shell");
var fso = new ActiveXObject("Scripting.FileSystemObject");
var pluginArguments = "";
var variables = new Array();
var mergeApp;

function get_PluginEvent() {
  return "EDITOR_SCRIPT";
}

function get_PluginDescription() {
  return "Basic text functions and AI-assisted text conversion functions";
}

function get_PluginFileFilters() {
  return ".*";
}

function get_PluginExtendedProperties() {
  return "GenerateUnpacker;" +
  "MakeUpper.MenuCaption=Make Uppercase;" +
  "MakeUpper.Description=Make characters uppercase;" +
  "MakeLower.MenuCaption=Make Lowercase;" +
  "MakeLower.Description=Make characters lowercase;" +
  "RemoveDuplicates.MenuCaption=Remove Duplicate Lines;" +
  "RemoveDuplicates.Description=Remove duplicate lines;" +
  "CountDuplicates.MenuCaption=Count Duplicate Lines;" +
  "CountDuplicates.Description=Count duplicate lines;" +
  "SortAscending.MenuCaption=Sort Lines Ascending;" +
  "SortAscending.Description=Sort lines ascending;" +
  "SortDescending.MenuCaption=Sort Lines Descending;" +
  "SortDescending.Description=Sort lines descending;" +
  "ExecFilterCommand.MenuCaption=Apply Filter Command...;" +
  "ExecFilterCommand.Description=Apply filter command. \r\n" +
    "Usage: ExecFilterCommand COMMAND\r\n"+ 
    "  COMMAND - command to execute. %1 in the command is replaced with the filename.;" +
  "ExecFilterCommand.ArgumentsRequired;" +
  "Tokenize.MenuCaption=Tokenize...;" +
  "Tokenize.Description=Tokenize selection. \r\n" +
    "Usage: Tokenize PATTERNS\r\n" +
    "  PATTERNS - regular expression for tokenizing. (e.g. [^\\w]+);" +
  "Tokenize.ArgumentsRequired;" +
  "Tokenize.Arguments=[^\\w]+;" +
  "Trim.MenuCaption=Trim Spaces;" +
  "Trim.Description=Trim spaces;" +
  "SelectColumns.MenuCaption=Select Columns...;" +
  "SelectColumns.Description=Select some columns.\r\n" +
    "Usage: SelectColumns RANGES\r\n" +
    "   or: SelectColumns [-v] [-i] [-g] -e PATTERNS\r\n" +
    "  RANGES   - list of column ranges to select. (e.g. -3,5-10,30-)\r\n" +
    "  PATTERNS - regular expression\r\n" +  
    "  -v - select non-matching columns\r\n" +  
    "  -i - ignore case\r\n" +  
    "  -g - enable global flag\r\n" +  
    "  -e - use PATTERNS for matching;" +
  "SelectColumns.ArgumentsRequired;" +
  "SelectLines.MenuCaption=Select Lines...;" +
  "SelectLines.Description=Select some lines.\r\n" +  
    "Usage: SelectLines RANGES\r\n" +  
    "   or: SelectLines [-v] [-i] -e PATTERNS\r\n" +  
    "  RANGES   - list of line ranges to select. (e.g. -3,5-10,30-)\r\n" +  
    "  PATTERNS - regular expression\r\n" +  
    "  -v - select non-matching lines\r\n" +  
    "  -i - ignore case\r\n" +  
    "  -e - use PATTERNS for matching;" +
  "SelectLines.ArgumentsRequired;" +
  "ReverseColumns.MenuCaption=Reverse Columns;" +
  "ReverseColumns.Description=Reverse columns;" +
  "ReverseLines.MenuCaption=Reverse Lines;" +
  "ReverseLines.Description=Reverse lines;" +
  "Replace.MenuCaption=Replace...;" +
  "Replace.Description=Replace text with another text.\r\n" +  
    "Usage: Replace [-i] [-e] FIND REPLACE\r\n" +  
    "   or: Replace -s\r\n" +  
    "  FIND    - text to find\r\n" +  
    "  REPLACE - text to replace\r\n" +  
    "  -i - ignore case (only for -e)\r\n" +  
    "  -e - treat the specified text as a regular expression\r\n" +
    "  -s - replace using Substitution Filters patterns;" +
  "Replace.ArgumentsRequired;" +
  "AIConvertText.MenuCaption=Convert Text with AI...;" +
  "AIConvertText.Description=Text converter using OpenAI API.\r\n" +  
    "Usage: AIConvertText PROMPT;" +  
  "AIConvertText.ArgumentsRequired;";
}

function get_PluginArguments() {
  return pluginArguments;
}

function put_PluginArguments(NewValue) {
  pluginArguments = NewValue;
}

function get_PluginVariables() {
  return variables.join("\0");
}

function put_PluginVariables(NewValue) {
  variables = NewValue.split("\0");
}

function regRead(Key, DefaultValue) {
  return mergeApp.GetOption(Key, DefaultValue);
}

function regWrite(Key, Value, TypeNm) {
  mergeApp.SaveOption(Key, (TypeNm === "REG_DWORD") ? parseInt(Value, 10) : String(Value));
}

function ReplaceVariables(str) {
  var newstr = "";
  var pos = 0;
  while (true) {
    var foundpos = str.indexOf("%", pos);
    if (foundpos > 0) {
      var ch = str.charAt(foundpos + 1);
      if (ch === "%") {
        newstr = newstr + "%";
        pos = foundpos + 2;
      } else if (!isNaN(ch)) {
        newstr = newstr + str.substr(pos, foundpos - pos);
        if (parseInt(ch, 10) < variables.length) {
          newstr = newstr + variables(parseInt(ch, 10));
        }
        pos = foundpos + 2;
      } else {
        newstr = newstr + str.substr(pos, foundpos - pos + 1);
        pos = foundpos + 1;
      }
  } else {
      newstr = newstr + str.substr(pos);
      break;
    }
  }
  return newstr;
}

function IsFirstArgumentEmpty() {
  return (pluginArguments.match(/^\s*$/) !== null);
}

function ParseArguments(args) {
  var ary = new Array();
  var token = "";
  var argsLen = args.length;
  var inQuotes = false;
  for (var i = 0; i < argsLen; i++) {
    var ch = args.charAt(i);
    if (!inQuotes) {
      if (ch === " " || ch === "\t") {
        if (token.length > 0) {
          ary.push(token);
          token = "";
        }
      } else if (ch === "\"") {
        inQuotes = true;
      } else {
        token += ch;
      }
    } else {
      if (ch === "\"") {
        if (i + 1 < argsLen) {
          if (args.charAt(i) === "\"") {
            token += ch;
          }
        }
        inQuotes = false;
      } else {
        token += ch;
      }
    }
  }
  if (token.length > 0) {
    ary.push(token);
    token = "";
  }
  return ary; 
}

function ParseRanges(rangeText) {
  var aryRanges = new Array();
  var ary = rangeText.split(",");
  for (var i = 0, j = 0; i < ary.length; i++) {
    var ary2 = ary[i].split("-");
    var rangeFrom = "";
    if (ary2.length > 0) {
      rangeFrom = ary2[0].replace(/^\s+|\s+$/g, "");
    }
    var rangeTo = rangeFrom;
    if (ary2.length > 1) {
      rangeTo = ary2[1].replace(/^\s+|\s+$/g, "");
    }
    if ((rangeFrom !== "" && !isNaN(rangeFrom)) || (rangeTo !== "" && !isNaN(rangeTo))) {
      if (rangeFrom === "" || isNaN(rangeFrom)) { rangeFrom = 1; }
      if (rangeTo === "" || isNaN(rangeTo)) { rangeTo = 1000000000; }
      if (parseFloat(rangeFrom) < 1 || parseFloat(rangeFrom) > 1000000000) { rangeFrom = 1; }
      if (parseFloat(rangeTo) < 1 || parseFloat(rangeTo) > 1000000000) { rangeTo = 1; }
      if (parseFloat(rangeFrom) > parseFloat(rangeTo)) { rangeTo = rangeFrom; }
      aryRanges.push([parseInt(rangeFrom, 10), parseInt(rangeTo, 10)]);
    }
    }
  return aryRanges;
}

function ParseSelectColumnsLinesArguments(args) {
  var rangesOrRegExps = new Array();
  var argAry = ParseArguments(args);
  var invert = false;
  var flags = "";
  var isRegExp = false;
  for (var i = 0; i < argAry.length; i++) {
    var isOption = false;
    if (argAry[i].length >= 2) {
      switch (argAry[i].charAt(0)) {
      case "-":
      case "/":
        switch (argAry[i].charAt(1)) {
        case "e":
        case "i":
        case "g":
          isRegExp = true;
          isOption = true;
          if (argAry[i].indexOf("g") >= 0) {
            flags += "g";
          }
          if (argAry[i].indexOf("i") >= 0) {
            flags += "i";
          }
          break;
        case "v":
          isOption = true;
          invert = true;
          break;
        }
        break;
      }
    }
    if (!isOption) {
      if (isRegExp) {
        rangesOrRegExps.push(new RegExp(argAry[i], flags));
        isRegExp = false;
      } else {
        rangesOrRegExps.push(ParseRanges(argAry[i]));
      }
    }
  }
  return { "rangesOrRegExps": rangesOrRegExps, "invert": invert };
}

function ParseReplaceArguments(args) {
  var list = new Array();
  var patterns = new Array();
  var isOption = false;
  var argAry = ParseArguments(args);
  var regex = false;
  var ignoreCase = false;
  var useSubstitutionFilters = false;
  for (var i = 0; i < argAry.length; i++) {
    isOption = false;
    if (argAry[i].length >= 2) {
      switch (argAry[i].charAt(0)) {
      case "-":
      case "/":
        switch (argAry[i].charAt(1)) {
        case "e":
        case "i":
          isOption = true;
          regex = true;
          if (argAry[i].indexOf("i") >= 0) {
            ignoreCase = true;
          }
          break;
        case "s":
          useSubstitutionFilters = true;
          break;
        }
        break;
      }
    }
    if (!isOption) {
      patterns.push(argAry[i]);
      if (patterns.length === 1) {
        list.push({"patterns": patterns, "regex": regex, "ignoreCase": ignoreCase});
      } else {
        list[list.length - 1].patterns.push(argAry[i]);
        patterns = new Array();
      }
    }
  }
  if (useSubstitutionFilters) {
    var count = regRead("SubstitutionFilters/Values", 0);
    for (var i = 0; i < count; i++) {
      var ii = "00" + i;
      ii = ii.substring(ii.length - 2);
      if (regRead("SubstitutionFilters/Enabled" + ii, 0)) {
        patterns = new Array();
        patterns.push(regRead("SubstitutionFilters/Pattern" + ii, ""));
        patterns.push(regRead("SubstitutionFilters/Replacement" + ii, ""));
        regex = regRead("SubstitutionFilters/UseRegExp" + ii, 0);
        ignoreCase = !regRead("SubstitutionFilters/CaseSensitive" + ii, 1);
        if (regRead("SubstitutionFilters/MatchWholeWordOnly" + ii, 0)) {
          regex = true;
          patterns[0] = "\\b" + Escape(patterns[0]) + "\\b";
          patterns[1] = Escape(patterns[1]);
        }
        list.push({"patterns": patterns, "regex": regex, "ignoreCase": ignoreCase});
      }
    }
  }
  return list;
}

function Escape(text) {
  var result = "";
  for (var i = 0; i < text.length; i++) {
    var c = text.charAt(i);
    switch (c) {
    case '\\': case '.': case '^': case '$': case '|':
    case '[': case ']': case '(': case ')': case '!':
    case '?': case '*': case '+': case '{': case '}':
        result += '\\';
        break;
    default:
        break;
    }
    result += c;
  }
  return result;
}

function Unescape(text) {
  var result = "";
  var textLen = text.length;
  var i = 0;
  while (i < textLen) {
    var ch = text.charAt(i);
    switch (ch) {
    case "\\":
      if (i < textLen - 1) {
        i++;
        ch = text.charAt(i);
        switch (ch) {
        case "a":
          result += String.fromCharCode(0x07);
          break;
        case "b":
          result += "\b";
          break;
        case "t":
          result += "\t";
          break;
        case "n":
          result += "\n";
          break;
        case "v":
          result += String.fromCharCode(0x0b);
          break;
        case "f":
          result += "\f";
          break;
        case "r":
          result += "\r";
          break;
        case "\\":
          result += "\\";
          break;
        case "x":
          if (i + 2 < textLen) {
            var hexValue = text.substring(i + 1, i + 3);
            try {
              var intValue = parseInt(hexValue, 16);
              result += String.fromCharCode(intValue);
              i += 2;
            } catch (e) {
              result += "\\x";
            }
          } else {
            result += "\\x";
          }
          break;
        default:
          if (!isNaN(ch)) {
            if (ch !== '0') {
              result += '$' + ch;
            } else {
              result += '$&';
            }
          } else {
            result += '\\' + ch;
          }
          break;
        }
      } else {
        result += ch;
      }
      break;
    default:
      result += ch;
      break;
    }
    i++;
  }
  return result;
}

function PluginOnEvent(eventType, obj) {
  mergeApp = obj;
}

// transformation functions
function MakeUpper(Text) {
  return Text.toUpperCase();
}

function MakeLower(Text) {
  return Text.toLowerCase();
}

function ExecFilterCommand(Text) {
  var cmd;
  if (IsFirstArgumentEmpty()) {
    cmd = regRead(REGKEY_PATH + "ExecFilterCommand", "");
    cmd = mergeApp.InputBox("Enter filter command", "ExecFilterCommand", cmd);
    if (cmd !== "") {
      regWrite(REGKEY_PATH + "ExecFilterCommand", cmd, "REG_SZ");
    }
    cmd = ReplaceVariables(cmd);
  } else {
    cmd = pluginArguments;
  }
  if (cmd === "") {
    throw new Error(30001, "Canceled");
  }

  var path = wsh.ExpandEnvironmentStrings("%TEMP%\\_winmerge_addin_temp_.txt");
  var fso = new ActiveXObject("Scripting.FileSystemObject");
  try {
    var ts = fso.CreateTextFile(path, true, true);
    ts.Write(Text);
    ts.Close();
  } catch (e) {
    throw new Error(30001, "Failed to create the file '" + path + "':" + e.message);
  }
  var result = "";
  try {
    var exe = wsh.Exec("cmd /c type \"" + path + "\" | " + cmd + " 2>&1");
    while (!exe.StdOut.AtEndOfStream) {
      result += exe.StdOut.ReadLine() + "\r\n";
    }
  } catch (e) {
    throw new Error(30001, "Failed to execute the command '" + cmd + "':" + e.message);
  } finally {
    fso.DeleteFile(path);
  }
  return result;
}

function SelectColumns(Text) {
  var args;
  if (IsFirstArgumentEmpty()) {
    args = regRead(REGKEY_PATH + "SelectColumns", "");
    args = mergeApp.InputBox("Enter the list of column ranges to select (e.g. -3,5-10,30-)\r\nor regular expression:", "SelectColumns", args);
    if (args !== "") {
      regWrite(REGKEY_PATH + "SelectColumns", args, "REG_SZ");
    }
  } else {
    args = pluginArguments;
  }
  if (args === "") {
    throw new Error(30001, "Canceled");
  }
  var eol = Text.match(/\r\n|\n|\r/);
  var lines = Text.split(eol);
  var parseResult = ParseSelectColumnsLinesArguments(args);
  var rangesOrRegExps = parseResult.rangesOrRegExps;
  var invert = parseResult.invert;
  for (var i = 0; i < lines.length; i++) {
    var line = "";
    for (var j = 0; j < rangesOrRegExps.length; j++) {
      if (rangesOrRegExps[j] instanceof Array) {
        for (var k = 0; k < rangesOrRegExps[j].length; k++) {
          if (rangesOrRegExps[j][k][0] - 1 < lines[i].length) {
            line += lines[i].substring(rangesOrRegExps[j][k][0] - 1, rangesOrRegExps[j][k][1]);
          }
        }
      } else {
        if (!invert) {
          var matches = lines[i].match(rangesOrRegExps[j]);
          if (matches) {
            for (var k = 0; k < matches.length; k++) {
              line += matches[k];
            }
          }
        } else {
          line += lines[i].replace(rangesOrRegExps[j], "");
        }
      }
    }
    lines[i] = line;
  }
  return lines.join(eol);
}

function SelectLines(Text) {
  var args;
  var newlines = new Array();
  if (IsFirstArgumentEmpty()) {
    args = regRead(REGKEY_PATH + "SelectLines", "");
    args = mergeApp.InputBox("Enter the list of line ranges to select (e.g. -3,5-10,30-)\r\nor regular expression:", "SelectLines", args);
    if (args !== "") {
      regWrite(REGKEY_PATH + "SelectLines", args, "REG_SZ");
    }
  } else {
    args = pluginArguments;
  }
  if (args === "") {
    throw new Error(30001, "Canceled");
  }
  var eol = Text.match(/\r\n|\n|\r/);
  var lines = Text.split(eol);
  var parseResult = ParseSelectColumnsLinesArguments(args);
  var invert = parseResult.invert;
  var rangesOrRegExps = parseResult.rangesOrRegExps;
  for (var i = 0; i < rangesOrRegExps.length; i++) {
    if (rangesOrRegExps[i] instanceof Array) {
      for (var j = 0; j < rangesOrRegExps[i].length; j++) {
        var max = rangesOrRegExps[i][j][1];
        if (max > lines.length) { max = lines.length; }
        for (var k = rangesOrRegExps[i][j][0] - 1; k < max; k++) {
          if (k < lines.length) {
            newlines.push(lines[k]);
          }
        }
      }
    } else {
      for (var j = 0; j < lines.length; j++) {
        var matched = (lines[j].match(rangesOrRegExps[i]) !== null);
        if (invert) { matched = !matched; }
        if (matched) {
          newlines.push(lines[j]);
        }
      }
    }
  }
  if (lines.length > 0) {
    if (lines[lines.length - 1] === "") {
      if (newlines.length > 0) {
        if (newlines[newlines.length - 1] !== "") {
          newlines.push("");
        }
      }
    }
  }
  return newlines.join(eol);
}

function replacei(text, find, replace, ignorecase) {
  if (!ignorecase)
    return text.split(find).join(replace);
  var textLower = text.toLowerCase();
  var findLower = find.toLowerCase();
  var pos = textLower.length;
  while (pos >= 0 && (pos = textLower.lastIndexOf(findLower, pos)) >= 0) {
    text = text.substr(0, pos) + replace + text.substr(pos + findLower.length);
    pos--;
  }
  return text;
}

function ReplaceText(Text) {
  var args;
  var result = Text;
  if (IsFirstArgumentEmpty()) {
    args = regRead(REGKEY_PATH + "Replace", "");
    args = mergeApp.InputBox("Enter the search text and replacement text:", "Replace", args);
    if (args !== "") {
      regWrite(REGKEY_PATH + "Replace", args, "REG_SZ");
    }
  } else {
    args = pluginArguments;
  }
  if (args === "") {
    throw new Error(30001, "Canceled");
  }
  var parseResult = ParseReplaceArguments(args);
  for (var i = 0; i < parseResult.length; i++) {
    var patterns = parseResult[i].patterns;
    var regex = parseResult[i].regex;
    var ignoreCase = parseResult[i].ignoreCase;
    if (regex) {
      var re = new RegExp(patterns[0], ignoreCase ? "gmi" : "gm");
      if (patterns.length > 1) {
        result = result.replace(re, Unescape(patterns[1]));
      } else {
        result = result.replace(re, result, "");
      }
    } else {
      if (patterns.length > 1) {
        result = replacei(result, patterns[0], patterns[1], ignoreCase);
      } else {
        result = replacei(result, patterns[0], "", ignoreCase);
      }
    }
  }
  return result;
}

// port from WinMerge2011
function Tokenize(Text) {
  var pattern;
  if (IsFirstArgumentEmpty()) {
    pattern = regRead(REGKEY_PATH + "Tokenize", "");
    pattern = mergeApp.InputBox("Enter regex to tokenize (e.g. [^\\w]+):", "Tokenize", pattern);
    if (pattern !== "") {
      regWrite(REGKEY_PATH + "Tokenize", pattern, "REG_SZ");
    }
  } else {
    pattern = pluginArguments;
  }
  if (pattern === "") {
    throw new Error(30001, "Canceled");
  }
  var re = new RegExp(pattern, "gi");
  return Text.replace(re, "\r\n");
}

function RemoveDuplicates(Text) {
  var eol = Text.match(/\r\n|\n|\r/);
  var lines = Text.split(eol);
  var newlines = new Array();
  var dic = {};
  var lasteol = false;

  if (!lines[lines.length - 1]) {
    lines.pop();
    lasteol = true;
  }
  for (var i = 0, j = 0; i < lines.length; i++) {
    var line = lines[i];
    if (typeof dic[line] === 'undefined') {
      dic[line] = 1;
      newlines.push(line);
    }
  }
  if (lasteol)
    newlines.push("");
  return newlines.join(eol);
}

function CountDuplicates(Text) {
  var eol = Text.match(/\r\n|\n|\r/);
  var lines = Text.split(eol);
  var newlines = new Array();
  var dic = {};

  if (!lines[lines.length - 1]) {
    lines.pop();
  }
  
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];
    if (typeof dic[line] === 'undefined') {
      dic[line] = 1;
      newlines.push(line);
    } else {
      dic[line]++;
    }
  }
  var j = 0;
  for (var line in dic) {
    newlines[j] = line + '\t' + dic[line];
    j++;
  }
  if (eol)
    newlines[j] = "";
  return newlines.join(eol);
}

function ReverseColumns(Text) {
  var eol = Text.match(/\r\n|\n|\r/);
  var lines = Text.split(eol);
  var lasteol = false;
  if (!lines[lines.length - 1]) {
    lines.pop();
    lasteol = true;
  }
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];
    var newline = "";
    for (var j = 0; j < line.length; j++)
      newline += line.substr(line.length - j - 1, 1);
    lines[i] = newline;
  }
  if (lasteol)
    lines.push("");
  return lines.join(eol);
}

function ReverseLines(Text) {
  var eol = Text.match(/\r\n|\n|\r/);
  var lines = Text.split(eol);
  var lasteol = false;
  if (!lines[lines.length - 1]) {
    lines.pop();
    lasteol = true;
  }
  var m = parseInt(lines.length / 2, 10);
  for (var i = 0; i < m; i++) {
    var line = lines[i];
    lines[i] = lines[lines.length - i - 1];
    lines[lines.length - i - 1] = line;
  }
  if (lasteol)
    lines.push("");
  return lines.join(eol);
}

function SortAscending(Text) {
  var eol = Text.match(/\r\n|\n|\r/);
  var lines = Text.split(eol);

  if (lines.length == 1) {
    return Text;
  } else if (lines[lines.length - 1] == "") {
    lines.pop();
    return lines.sort().join(eol) + eol;
  } else {
    return lines.sort().join(eol);
  }
}

function SortDescending(Text) {
  var eol = Text.match(/\r\n|\n|\r/);
  var lines = Text.split(eol);

  if (lines.length == 1) {
    return Text;
  } else if (lines[lines.length - 1] == "") {
    lines.pop();
    lines.sort(function(a, b) { return a < b ? 1 : -1; });
    return lines.join(eol) + eol;
  } else {
    return lines.sort(function(a, b) { return a < b ? 1 : -1; }).join(eol);
  }
}

function Trim(Text) {
  var eol = Text.match(/\r\n|\n|\r/);
  var lines = Text.split(eol);
  for (var i = 0; i < lines.length; i++) {
    lines[i] = lines[i].replace(/^\s+|\s+$/g, "");
  }
  return lines.join(eol);
}

function quote(text) {
  return text.replace(/\\/g, "\\\\").replace(/\"/g, "\\\"").replace(/\r/g, "\\r").replace(/\n/g, "\\n")
}

function extractString(input) {
    var regex = /"((?:[^"\\]|\\.)*)"/g;
    var matches = [];
    var match;

    while ((match = regex.exec(input)) !== null) {
        matches.push(match[1]);
    }

    return matches;
}

function getContentOrErrorMessage(jsonString) {
  var extractedStrings = extractString(jsonString);
  for (var i = 0; i < extractedStrings.length; i++) {
    if (extractedStrings[i] === "content" && i + 1 < extractedStrings.length) {
       return Unescape(extractedStrings[i + 1]);
    }
  }
  return jsonString;
}

function setEnvVal(name, value) {
  wsh.Exec("setx " + name + " \"" + value + "\"");
}

function getOpenAIKey() {
  var keyEnvName = regRead(REGKEY_PATH + "AIConvertText.OpenAI.ApiKeyEnvName", "OPENAI_API_KEY");
  var openAIKey = wsh.ExpandEnvironmentStrings("%" + keyEnvName + "%");
  if (openAIKey === "" || openAIKey === "%" + keyEnvName + "%") {
    try {
      openAIKey = wsh.RegRead("HKEY_CURRENT_USER\\Environment\\" + keyEnvName);
    } catch (e) {
      openAIKey = "";
    }
    if (openAIKey === "") {
      var msg = mergeApp.Translate("Enter your OpenAI API key.\r\n - Use of this plugin requires registration with OpenAI and incurs fees.\r\n - The API key is stored in the environment variable %1.");
      msg = msg.replace("%1", keyEnvName);
      openAIKey = mergeApp.InputBox(msg, "AIConvertText plugin", "");
      if (openAIKey !== "") {
        setEnvVal(keyEnvName, openAIKey);
      }
    }
  }
  return openAIKey;
}

function AIConvertText(Text) {
  var openAIKey = getOpenAIKey();
  var cmd;
  if (IsFirstArgumentEmpty()) {
    cmd = regRead(REGKEY_PATH + "AIConvertText.Prompt", "");
    cmd = mergeApp.InputBox(mergeApp.Translate("Enter prompt"), "AIConvertText plugin", cmd);
    if (cmd !== "") {
      regWrite(REGKEY_PATH + "AIConvertText.Prompt", cmd, "REG_SZ");
    }
    cmd = ReplaceVariables(cmd);
  } else {
    cmd = pluginArguments;
  }
  if (cmd === "") {
    throw new Error(30001, "Canceled");
  }
  var openAIUrl = "https://api.openai.com/v1/chat/completions";
  var temperature = regRead(REGKEY_PATH + "AIConvertText.OpenAI.Temperature", "1.00");
  var maxTokens = regRead(REGKEY_PATH + "AIConvertText.OpenAI.MaxTokens", 4096);
  var model = regRead(REGKEY_PATH + "AIConvertText.OpenAI.Model", "gpt-3.5-turbo");
  var body = '{"model": "' + model + '", "temperature": ' + Number(temperature) + ', "messages": [{"role": "system", "content": "' + quote(cmd) + '"}, {"role": "user", "content": "' + quote(Text) + '"}]}';
  var xmlHttp = new ActiveXObject("Msxml2.ServerXMLHTTP");
  xmlHttp.open("POST", openAIUrl, false);
  xmlHttp.setRequestHeader("Content-Type", "application/json");
  xmlHttp.setRequestHeader("Authorization", "Bearer " + openAIKey);
  xmlHttp.send(body);
  return getContentOrErrorMessage(xmlHttp.responseText) ;
}

function translate(text) {
  var re = /\${([^}]+)}/g;
  var matches;
  while ((matches = re.exec(text)) != null) {
    text = text.replace(matches[0], mergeApp.Translate(matches[1]));
  }
  return text;
}

function ShowSettingsDialog() {
  var tname = fso.BuildPath(fso.GetSpecialFolder(2), fso.GetTempName() + ".hta");
  var xmlfile = fso.BuildPath(fso.GetSpecialFolder(2), fso.GetTempName() + ".xml");
  var tfile = fso.CreateTextFile(tname, true, true);
  tfile.Write(translate(getResource("dialog1")));
  tfile.Close();
  exportSettingsToXMLFile(xmlfile);
  var mshta = wsh.ExpandEnvironmentStrings("%SystemRoot%\\System32\\mshta.exe");
  if (!fso.FileExists(mshta)) {
    mshta = wsh.ExpandEnvironmentStrings("%SystemRoot%\\SysWOW64\\mshta.exe");
  }
  run(wsh, "\"" + mshta + "\" \"" + tname + "\"  \"" + xmlfile + "\"");
  importSettingsFromXMLFile(xmlfile);
  fso.DeleteFile(tname);
  fso.DeleteFile(xmlfile);
}

function run(sh, cmd) {
  sh.Run(cmd, 1, true);
}

function exportSettingsToXMLFile(filepath) {
  var key_defvalues = {
    "AIConvertText.OpenAI.ApiKeyEnvName": "OPENAI_API_KEY",
    "AIConvertText.OpenAI.Temperature": "1.00",
    "AIConvertText.OpenAI.MaxTokens": 4096,
    "AIConvertText.OpenAI.Model": "gpt-3.5-turbo"
  };
  var doc = new ActiveXObject("MSXML2.DOMDocument");
  var fso = new ActiveXObject("Scripting.FileSystemObject");
  var ts = fso.OpenTextFile(filepath, 2, true, -1);
  var root = doc.createElement("properties");
  for (var key in key_defvalues) {
    var el = doc.createElement("property");
    var val = regRead(REGKEY_PATH + key, key_defvalues[key]);
    var cdata = doc.createCDATASection(val);
    el.appendChild(cdata);
    el.setAttribute("name", REGKEY_PATH + key);
    el.setAttribute("type", typeof val);
    root.appendChild(el);
  }
  doc.appendChild(root);
  ts.Write(doc.xml);
  ts.Close();
}

function importSettingsFromXMLFile(filepath) {
  var fso = new ActiveXObject("Scripting.FileSystemObject");
  var ts = fso.OpenTextFile(filepath, 1, true, -1);
  var xml = ts.ReadAll();
  var doc = new ActiveXObject("MSXML2.DOMDocument");
  doc.async = false;
  doc.loadXML(xml);
  ts.Close();
  var nodes = doc.documentElement.childNodes;
  for (var i = 0; i < nodes.length; i++) {
    regWrite(nodes[i].getAttribute("name"), nodes[i].text, (nodes[i].getAttribute("type") === "string") ? "REG_SZ" : "REG_DWORD");
  }
}

</script>

<resource id="dialog1">
<![CDATA[
<!DOCTYPE html>
<html>
  <head>
    <HTA:APPLICATION ID="objHTA">
    <title>${editor addin.sct WinMerge Plugin Options}</title>
    <meta content="text/html" charset="UTF-16">
    <style>
    body { background-color: #f2f2f2; font-family: Arial, sans-serif; }
    .container { margin: 2em; }
    ul { list-style-type: none; margin: 0; padding: 0; }
    li ul li { padding-left: 2em }
    .btn-container { margin-top: 1.5em; text-align: right; }
    input[type="button"] { border: none; padding: 0.6em 2em; height: 2.5em; text-align: center; }
    .btn-ok { color: #fff; background-color: #05c; }
    .btn-ok:hover { background-color: #04b; }
    .btn-cancel { color: #333; background-color: #ddd; }
    .btn-cancel:hover { background-color: #ccc; }
    </style>
    <script type="text/javascript">
      var REGKEY_PATH = "Plugins\\editor addin.sct/";
      var xmlFilePath;
      var settings = {};
      var wsh = new ActiveXObject("WScript.Shell");
      var openAIKey = "";

      function regRead(key, defaultValue) {
        return settings.hasOwnProperty(key) ? settings[key] : defaultValue;
      }

      function regWrite(key, value, type) {
        settings[key] = (type === "REG_DWORD") ? Number(value) : String(value);
      }

      function setEnvVal(name, value) {
        wsh.Exec("setx " + name + " \"" + value + "\"");
      }

      function loadSettingsFromXMLFile(filepath) {
        var fso = new ActiveXObject("Scripting.FileSystemObject");
        var ts = fso.OpenTextFile(filepath, 1, true, -1);
        var xml = ts.ReadAll();
        var doc = new ActiveXObject("MSXML2.DOMDocument");
        doc.async = false;
        doc.loadXML(xml);
        ts.Close();
        var nodes = doc.documentElement.childNodes;
        for (var i = 0; i < nodes.length; i++) {
          regWrite(nodes[i].getAttribute("name"), nodes[i].text, (nodes[i].getAttribute("type") === "string") ? "REG_SZ" : "REG_DWORD");
        }
        return settings;
      }

      function saveSettingsToXMLFile(filepath, settings) {
        var doc = new ActiveXObject("MSXML2.DOMDocument");
        var fso = new ActiveXObject("Scripting.FileSystemObject");
        var ts = fso.OpenTextFile(filepath, 2, true, -1);
        var root = doc.createElement("properties");
        for (var key in settings) {
          if (settings.hasOwnProperty(key)) {
            var el = doc.createElement("property");
            var val = settings[key];
            var cdata = doc.createCDATASection(val);
            el.appendChild(cdata);
            el.setAttribute("name", key);
            el.setAttribute("type", typeof val);
            root.appendChild(el);
          }
        }
        doc.appendChild(root);
        ts.Write(doc.xml);
        ts.Close();
      }

      function getOpenAIKey(keyEnvName) {
        var openAIKey = wsh.ExpandEnvironmentStrings("%" + keyEnvName + "%");
        if (openAIKey === "" || openAIKey === "%" + keyEnvName + "%") {
          try {
            openAIKey = wsh.RegRead("HKEY_CURRENT_USER\\Environment\\" + keyEnvName);
          } catch (e) {
            openAIKey = "";
          }
        }
        return openAIKey;
      }

      function onload() {
        xmlFilePath = objHTA.commandLine.split('"')[3];
        settings = loadSettingsFromXMLFile(xmlFilePath);

        var dpi = window.screen.deviceXDPI;
        var w = 600 * dpi / 96, h = 500 * dpi / 96;
        window.resizeTo(w, h);
        window.moveTo((screen.width - w) / 2, (screen.height - h) / 2);

        var keyEnvName = regRead(REGKEY_PATH + "AIConvertText.OpenAI.ApiKeyEnvName", "OPENAI_API_KEY");
        openAIKey = getOpenAIKey(keyEnvName);

        txtApiKeyEnvName.value = keyEnvName;
        txtApiKey.value = openAIKey;
        txtTemperature.value = regRead(REGKEY_PATH + "AIConvertText.OpenAI.Temperature", "1.00");
        txtMaxTokens.value = regRead(REGKEY_PATH + "AIConvertText.OpenAI.MaxTokens", 4096);
        cboModel.value = regRead(REGKEY_PATH + "AIConvertText.OpenAI.Model", "gpt-3.5-turbo");
        document.onkeydown = onkeydown;
      }

      function onkeydown() {
        var k = event.keyCode;
        if (k == 13/*Enter*/) {
          btnOk_onclick();
        } else if (k == 27/*Escape*/) {
          btnCancel_onclick();
        }
      }

      function btnOk_onclick() {
        var temperature = Number(txtTemperature.value);
        var maxTokens = Number(txtMaxTokens.value);
        if (isNaN(temperature)) {
          temperature = 1.0;
        }
        if (temperature < 0.0) {
          temperature = 0.0;
        }
        if (temperature > 2.0) {
          temperature = 2.0;
        }
        if (isNaN(maxTokens)) {
          maxTokens = 4096;
        }
        if (cboModel.value === "gpt-3.5-turbo-16k") {
          if (maxTokens < 0 || maxTokens > 16384) {
            maxTokens = 16384;
          }
        } else {
          if (maxTokens < 0 || maxTokens > 4096) {
            maxTokens = 4096;
          }
        }
        regWrite(REGKEY_PATH + "AIConvertText.OpenAI.ApiKeyEnvName", txtApiKeyEnvName.value, "REG_SZ");
        regWrite(REGKEY_PATH + "AIConvertText.OpenAI.Temperature", temperature, "REG_SZ");
        regWrite(REGKEY_PATH + "AIConvertText.OpenAI.MaxTokens", maxTokens, "REG_DWORD");
        regWrite(REGKEY_PATH + "AIConvertText.OpenAI.Model", cboModel.value, "REG_SZ");
        if (txtApiKey.value !== openAIKey) {
          setEnvVal(txtApiKeyEnvName.value, txtApiKey.value);
          alert("${OpenAI API key has changed. Please restart WinMerge to apply the changes.}");
        }

        saveSettingsToXMLFile(xmlFilePath, settings);

        window.close();
      }

      function btnCancel_onclick() {
        saveSettingsToXMLFile(xmlFilePath, {});

        window.close();
      }

      function onlyNumeric() {
        var ev = event;
        var k = ev.keyCode;

        if (ev.shiftKey) {
          if (k == 37 || k == 39) {
            return true;
          }
        } else if (ev.altKey) {
          return true;
        } else if (ev.ctrlKey) {
          return true;
        } else if (k == 8 || k == 9 || k == 37 || k == 39 || k == 46 /* || k == 144 */
            || (48 <= k && k <= 57) || (96 <= k && k <= 105)) {
          return true;
        }

        ev.returnValue = false;
        return false;
      }
    </script>
  </head>
  <body onload="onload();">
    <div class="container">
      <ul>
        <li>
          <label for="txtApiKeyEnvName">${Environment variable name for OpenAI API key}:</label>
        </li>
        <li>
          <input id="txtApiKeyEnvName" type="text" />
        </li>
        <li>
          <label for="txtApiKey">${OpenAI API key}:</label>
        </li>
        <li>
          <input id="txtApiKey" type="password" />
        </li>
        <li>
          <label for="txtTemperature">${Temperature}:</label>
        </li>
        <li>
          <input id="txtTemperature" type="text" />
        </li>
        <li>
        </li>
          <label for="txtMaxTokens">${Maximum length}:</label>
        <li>
          <input id="txtMaxTokens" type="text" />
        </li>
        <li>
          <label for="cboModel">${Model}:</label>
        </li>
        <li>
          <select id="cboModel">
            <option value="gpt-4-turbo">gpt-4-turbo</option>
            <option value="gpt-4">gpt-4</option>
            <option value="gpt-3.5-turbo">gpt-3.5-turbo</option>
            <option value="gpt-3.5-turbo-16k">gpt-3.5-turbo-16k</option>
          </select>
        </li>
      </ul>
      <div class="btn-container">
        <input type="button" class="btn-ok" onclick="btnOk_onclick();" value="${OK}" />
        <input type="button" class="btn-cancel" onclick="btnCancel_onclick();" value="${Cancel}" />
      </div>
    </div>
  </body>
</html>
]]>
</resource>

</scriptlet>
